#!/sbin/sh
#制作：残芯此生不换
#2021.05.07
#



OUTFD=$2
if [ -n "$2" ];then
  readlink /proc/$$/fd/$OUTFD 2>/dev/null | grep /tmp >/dev/null
  if [ "$?" -eq "0" ]; then
    OUTFD=0
    for FD in `ls /proc/$$/fd`; do
      readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null
      if [ "$?" -eq "0" ]; then
        ps | grep " 3 $FD " | grep -v grep >/dev/null
        if [ "$?" -eq "0" ]; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  ui_print() {
    echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD
    echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD
  }
else
  ui_print() {
    echo "$1"
  }
fi

find_block() {
  local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
  for BLOCK in "$@"; do
    DEVICE=`find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1` 2>/dev/null
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done

  return 1
}



grep_cmdline() {
  local REGEX="s/^$1=//p"
  cat /proc/cmdline | tr '[:space:]' '\n' | sed -n "$REGEX" 2>/dev/null
}


find_boot_image() {
  BOOTIMAGE1=
  # Check A/B slot
  SLOT=`grep_cmdline androidboot.slot_suffix`
  if [ -z $SLOT ]; then
    SLOT=`grep_cmdline androidboot.slot`
    [ -z $SLOT ] || SLOT=_${SLOT}
  fi
  [ -z $SLOT ] || ui_print "- Current boot slot: $SLOT"

  BOOTIMAGE1=`find_block ramdisk$SLOT recovery_ramdisk$SLOT boot$SLOT`
	if  [ $SLOT = "_a" ]; then
	    BOOTIMAGE2=`find_block ramdisk_b recovery_ramdisk_b boot_b`
	elif [ $SLOT = "_b" ]; then
	    BOOTIMAGE2=`find_block ramdisk_a recovery_ramdisk_a boot_a`
	fi

}

flash_image() {
  case "$1" in
    *.gz) CMD1="gzip -d < '$1' 2>/dev/null";;
    *)    CMD1="cat '$1'";;
  esac
  CMD2="cat -"
  if [ -b "$2" ]; then
    local img_sz=$(stat -c '%s' "$1")
    local blk_sz=$(blockdev --getsize64 "$2")
    [ "$img_sz" -gt "$blk_sz" ] && return 1
    blockdev --setrw "$2"
    local blk_ro=$(blockdev --getro "$2")
    [ "$blk_ro" -eq 1 ] && return 2
    eval "$CMD1" | eval "$CMD2" | cat - /dev/zero > "$2" 2>/dev/null
 
  else
    ui_print "- Not block or char device, storing image"

  fi
  return 0
}

xyen_dir_setup(){
	if [ -d /tmp/xyen_twrp_patch ];then
		rm -rf /tmp/xyen_twrp_patch
	fi
	mkdir -p /tmp/xyen_twrp_patch/origboot
	mkdir -p /tmp/xyen_twrp_patch/origboot2	
	bootdir=/tmp/xyen_twrp_patch/origboot
	bootdir2=/tmp/xyen_twrp_patch/origboot2
}

ui_print "---------------------------------------------------";
ui_print "         Install TWRP into the boot partition      ";
ui_print "                    Made by XYEN                   ";
ui_print "---------------------------------------------------";

xyen_dir_setup
find_boot_image
cd $bootdir
ui_print "Start Patching twrp to the first boot partition";
magiskboot unpack "$BOOTIMAGE1"
cp -rf /sbin/xyen_twrp_ramdisk.cpio ramdisk.cpio
magiskboot cpio ramdisk.cpio "add 0644 sbin/xyen_twrp_ramdisk.cpio /sbin/xyen_twrp_ramdisk.cpio"
umount /vendor 2>/dev/null
mount -o ro /vendor
magiskboot cpio ramdisk.cpio "add 0644  vendor/lib/modules/xiaomi_touch.ko /vendor/lib/modules/xiaomi_touch.ko"
magiskboot cpio ramdisk.cpio "add 0644  vendor/lib/modules/fts_touch_spi.ko /vendor/lib/modules/fts_touch_spi.ko"
umount /vendor 2>/dev/null
magiskboot repack $BOOTIMAGE1 patch_twrp_boot.img
flash_image patch_twrp_boot.img $BOOTIMAGE1
cd $bootdir2
ui_print "Start Patching twrp to the second boot partition";
magiskboot unpack "$BOOTIMAGE2"
cp -rf /sbin/xyen_twrp_ramdisk.cpio ramdisk.cpio
magiskboot cpio ramdisk.cpio "add 0644 sbin/xyen_twrp_ramdisk.cpio /sbin/xyen_twrp_ramdisk.cpio"
umount /vendor 2>/dev/null
mount -o ro /vendor
magiskboot cpio ramdisk.cpio "add 0644  vendor/lib/modules/xiaomi_touch.ko /vendor/lib/modules/xiaomi_touch.ko"
magiskboot cpio ramdisk.cpio "add 0644  vendor/lib/modules/fts_touch_spi.ko /vendor/lib/modules/fts_touch_spi.ko"
umount /vendor 2>/dev/null
magiskboot repack $BOOTIMAGE2 patch_twrp_boot2.img
flash_image patch_twrp_boot2.img $BOOTIMAGE2
ui_print "The installation is complete!";
rm -rf /tmp/xyen_twrp_patch
